{"meta":{"title":"杨小嘿の博客","subtitle":null,"description":"iOS Dev","author":"杨小嘿","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-10-14T16:58:16.000Z","updated":"2017-10-14T17:25:09.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Algorithms4 习题 1_1_7 详解-牛顿迭代法","slug":"Algorithms4-习题-1-1-7-详解-牛顿迭代法","date":"2017-10-24T05:39:52.000Z","updated":"2017-10-24T07:02:02.000Z","comments":true,"path":"2017/10/24/Algorithms4-习题-1-1-7-详解-牛顿迭代法/","link":"","permalink":"http://yoursite.com/2017/10/24/Algorithms4-习题-1-1-7-详解-牛顿迭代法/","excerpt":"","text":"描述 : 下面代码输出什么 ? 123456public static double practise_1_1_07_a(double c) &#123; double result = c; while(Math.abs(result - c / result) &gt; .0001) result = (c / result + result) / 2.0; return result;&#125; 上面的代码输出 c 的平方根，原理是牛顿迭代法，下面详述： 牛顿迭代法执行步骤牛顿迭代法是一种通过逐渐逼近求函数解的方法，如下动图所示 步骤1. 在函数曲线上任取一点(t, f(t))，做该点切线，与 x 轴有一交点 x0 步骤2. 过 x0 做垂线，与函数曲线交于点 (x0, f(x0)) 步骤3. 做 (x0, f(x0)) 做函数曲线的切线，与 x 轴有一交点 x1 步骤4. 回到步骤 2 牛顿迭代法递推式可以发现，每次做切线与 x 轴交点在逼近 f(x) = 0 的解，据此我们可以得到下列递推式 而求 a 的2次方根，即求使 x^2 - a 为0的解，此时f(x) = x^2 - a，带入牛顿迭代递推式得到平方根迭代递推式 举例来说，比如求 2 的2次方根，随意选取一个初始值 x0 = 1 重新解释 Java 代码我们可以随意选取 x0 的值，在上述 Java 程序中，选取 x0 = a，依然可以得到正确的结果。我们知道，随着 f(xn)/f&#39;(xn) -&gt; 0时，x(n+1) -&gt; x(n)，所以我们使用的循环的终止条件其实是整理后得到 添加注释版代码 12345678910111213public static double practise_1_1_07_a(double c) &#123; /** * 选取 x0 = c */ double result = c; /** * 终止条件为 (x(n) - a/x(n)) -&gt; 0 */ while(Math.abs(result - c / result) &gt; .0001) // 迭代 x(n+1) = 1/2 * (x(n) - a/x(n)) result = (c / result + result) / 2.0; return result;&#125;","categories":[{"name":"Algorithms4","slug":"Algorithms4","permalink":"http://yoursite.com/categories/Algorithms4/"}],"tags":[]},{"title":"Algorithms4 习题 1_1_27 详解","slug":"Algorithms4-习题-1-1-27-详解","date":"2017-10-21T07:58:03.000Z","updated":"2017-10-24T07:01:25.000Z","comments":true,"path":"2017/10/21/Algorithms4-习题-1-1-27-详解/","link":"","permalink":"http://yoursite.com/2017/10/21/Algorithms4-习题-1-1-27-详解/","excerpt":"","text":"描述: 二项分布 估计用以下代码计算 binomial(100, 50, 0.25) 将会产生的递归调用次数： 12345public static void binomial(int N, int k, double p) &#123; if (N == 0 &amp;&amp; k == 0) return 1.0; if (N &lt; 0 || k &lt; 0) return 0.0; return (1.0 - p) * binomial(N - 1, k ,p) + p * binomial(N - 1, k - 1, p);&#125; 将已经计算过的值保存在数组中并给出一个更好的实现 一，分析递归调用的次数假设 N = 3, k = 2, p = 0.75, 分析函数的执行路径，我们可以得到函数首先不断的进入左侧的 (1.0 - p) * binomial(N - 1, k ,p) 表达式中, k 不变而 N 一直递减, 直到 if (N &lt; 0 || k &lt; 0) return 0.0 返回 0.0 为止，才开始返回上一层函数，而在逐层返回的过程中，函数也在不断的进入右侧表达式 p * binomial(N - 1, k - 1, p), 将上述执行路径化成图像如下: 所以 N = 3, k = 2, p = 0.75 时，该函数总共调用次数为 23 次，观察发现，这是一棵由一分裂二的树状结构，假如每个节点都完整分裂两次，可以得出这棵树结构高度和总节点的函数关系 NodeCount(depth) = 2^(depth + 1) - 1，举例来说，高度为2，那么总共是7个节点，如下图所示: 因此我们可以得到递归调用次数的上限是 2^(N + 2) - 1，用代码验证结论： 12345678910double p = 0.8;for(int N = 1; N &lt; 10; N++) for(int k = 0; k &lt;= N; k++) &#123; binomial(N, k, p); StdOut.println(\"N = \" + N + \" k = \" + k); StdOut.println(\"递归调用次数: \" + recursive_count); StdOut.println(\"上限次数 : \" + (long)(Math.pow(2, N + 2) - 1)); StdOut.println(\"========================\\n\"); recursive_count = 0; &#125; 控制台输出: N = 1 k = 0 递归调用次数: 3 上限次数 : 7 ======================== N = 1 k = 1 递归调用次数: 5 上限次数 : 7 ======================== ... N = 7 k = 6 递归调用次数: 495 上限次数 : 511 ======================== N = 7 k = 7 递归调用次数: 509 上限次数 : 511 ======================== ... N = 9 k = 7 递归调用次数: 1953 上限次数 : 2047 ======================== N = 9 k = 8 递归调用次数: 2027 上限次数 : 2047 ======================== N = 9 k = 9 递归调用次数: 2045 上限次数 : 2047 ======================== 据此估算出 binomial(100, 50, 0.25) 的递归调用次数上限为 2^102 - 1 二，更好的实现每传入一个新的 N，都要回过头把已经算过数遍的 binomal(N - 1 ... ) 重新再算一遍，从上述图中可看出，binomial(-1, 1...) 和 binomial(-1, 0...) 重复计算了 4 次，binomial(0, 1...) 和 binomial(0, 0...) 重复计算了 3 次，递归调用造成大量计算的浪费，我们考虑使用一个数组，来存储已经计算过的值，当使用需要先前结果的计算时，可以直接从数组中取用。那么，使用数组存储结果，亦步亦趋的计算需要解决这么两个问题: 1，为数组分配多大容量 ? 对于 (N, k) 左侧递归会在 N = 0 时终止（忽略最后一步 N = -1 ），而右侧递归会在 k = 0 时达到最右树枝的极限长度，所以我们可以考虑分配 double[N + 1][k + 1] 的数组容量。 2，初始值如何设置在上述图中可以观察到，凡是 (N, k) 为 (N, 0) 形式的调用，总会在左侧递归中随着 N 递减，达到 (0, 0) 时函数第一次返回，在返回后过程中每次都陷入右侧递归，因为右侧递归需要 k 递减，而递归终止条件规定 if (N &lt; 0 || k &lt; 0) return 0.0 所以随着左侧递归每次返回而调用的第一次右侧递归，会因为 k &lt; 0 而立即返回，不会再有第二个以及往后的递归，并且返回的结果为 0.0,然而加一个0，其实等于啥都没干，所以我们忽略右侧递归，而把 (N, 0) 形式简单看作只在右侧递归深入并逐层返回的过程，再进一步，忽略最后一步递归终止条件，即 N = -1, 得出 (N, 0) 执行深度为 N + 1。再来考察 (N, k) 为 (0, k) 形式的调用,因为无论是右侧递归还是左侧递归，在下一次递归中都会因为 N &lt; 0 而终止，所以凡是 (0, k) 的结果都为 0。 综上所属得出代码:Github: Algorithms4_1.1.27","categories":[{"name":"Algorithms4","slug":"Algorithms4","permalink":"http://yoursite.com/categories/Algorithms4/"}],"tags":[]}]}