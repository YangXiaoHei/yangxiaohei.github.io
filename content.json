{"meta":{"title":"杨小嘿の博客","subtitle":null,"description":"iOS Dev","author":"杨小嘿","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-10-14T16:58:16.000Z","updated":"2017-10-14T17:25:09.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Algorithms4 习题 1_1_27 详解","slug":"Algorithms4-习题-1-1-27-详解","date":"2017-10-21T07:58:03.000Z","updated":"2017-10-21T09:37:05.000Z","comments":true,"path":"2017/10/21/Algorithms4-习题-1-1-27-详解/","link":"","permalink":"http://yoursite.com/2017/10/21/Algorithms4-习题-1-1-27-详解/","excerpt":"","text":"描述: 二项分布 估计用以下代码计算 binomial(100, 50, 0.25) 将会产生的递归调用次数： 12345public static void binomial(int N, int k, double p) &#123; if (N == 0 &amp;&amp; k == 0) return 1.0; if (N &lt; 0 || k &lt; 0) return 0.0; return (1.0 - p) * binomial(N - 1, k ,p) + p * binomial(N - 1, k - 1, p);&#125; 将已经计算过的值保存在数组中并给出一个更好的实现 一，分析递归调用的次数假设 N = 3, k = 2, p = 0.75, 分析函数的执行路径，我们可以得到函数首先不断的进入左侧的 (1.0 - p) * binomial(N - 1, k ,p) 表达式中, k 不变而 N 一直递减, 直到 if (N &lt; 0 || k &lt; 0) return 0.0 返回 0.0 为止，才开始返回上一层函数，而在逐层返回的过程中，函数也在不断的进入右侧表达式 p * binomial(N - 1, k - 1, p), 将上述执行路径化成图像如下: 所以 N = 3, k = 2, p = 0.75 时，该函数总共调用次数为 23 次，观察发现，这是一棵由一分裂二的树状结构，假如每个节点都完整分裂两次，可以得出这棵树结构高度和总节点的函数关系 NodeCount(depth) = 2^(depth + 1) - 1，举例来说，高度为2，那么总共是7个节点，如下图所示: 因此我们可以得到递归调用次数的上限是 2^(N + 2) - 1，用代码验证结论： 12345678910double p = 0.8;for(int N = 1; N &lt; 10; N++) for(int k = 0; k &lt;= N; k++) &#123; binomial(N, k, p); StdOut.println(\"N = \" + N + \" k = \" + k); StdOut.println(\"递归调用次数: \" + recursive_count); StdOut.println(\"上限次数 : \" + (long)(Math.pow(2, N + 2) - 1)); StdOut.println(\"========================\\n\"); recursive_count = 0; &#125; 控制台输出: N = 1 k = 0 递归调用次数: 3 上限次数 : 7 ======================== N = 1 k = 1 递归调用次数: 5 上限次数 : 7 ======================== ... N = 7 k = 6 递归调用次数: 495 上限次数 : 511 ======================== N = 7 k = 7 递归调用次数: 509 上限次数 : 511 ======================== ... N = 9 k = 7 递归调用次数: 1953 上限次数 : 2047 ======================== N = 9 k = 8 递归调用次数: 2027 上限次数 : 2047 ======================== N = 9 k = 9 递归调用次数: 2045 上限次数 : 2047 ======================== 据此估算出 binomial(100, 50, 0.25) 的递归调用次数上限为 2^102 - 1 二，更好的实现每传入一个新的 N，都要回过头把已经算过数遍的 binomal(N - 1 ... ) 重新再算一遍，从上述图中可看出，binomial(-1, 1...) 和 binomial(-1, 0...) 重复计算了 4 次，binomial(0, 1...) 和 binomial(0, 0...) 重复计算了 4 次，递归调用造成大量计算的浪费，我们考虑使用一个数组，来存储已经计算过的值，当使用需要先前结果的计算时，可以直接从数组中取用。那么，使用数组存储结果，亦步亦趋的计算需要解决这么两个问题: 1，为数组分配多大容量 ? 对于 (N, k) 左侧递归会在 N = 0 时终止（忽略最后一步 N = -1 ），而右侧递归会在 k = 0 时达到最右树枝的极限长度，所以我们可以考虑分配 double[N + 1][k + 1] 的数组容量。 2，初始值如何设置在上述图中可以观察到，凡是 (N, k) 为 (N, 0) 形式的调用，总会在左侧递归中随着 N 递减，达到 (0, 0) 时函数第一次返回，在返回后过程中每次都陷入右侧递归，因为右侧递归需要 k 递减，而递归终止条件规定 if (N &lt; 0 || k &lt; 0) return 0.0 所以随着左侧递归每次返回而调用的第一次右侧递归，会因为 k &lt; 0 而立即返回，不会再有第二个以及往后的递归，并且返回的结果为 0.0,然而加一个0，其实等于啥都没干，所以我们忽略右侧递归，而把 (N, 0) 形式简单看作只在右侧递归深入并逐层返回的过程，再进一步，忽略最后一步递归终止条件，即 N = -1, 得出 (N, 0) 执行深度为 N + 1。再来考察 (N, k) 为 (0, k) 形式的调用,因为无论是右侧递归还是左侧递归，在下一次递归中都会因为 N &lt; 0 而终止，所以凡是 (0, k) 的结果都为 0。 综上所属得出代码:Github: Algorithms4_1.1.27","categories":[{"name":"Algorithms4","slug":"Algorithms4","permalink":"http://yoursite.com/categories/Algorithms4/"}],"tags":[]}]}