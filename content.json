{"meta":{"title":"杨小嘿の博客","subtitle":null,"description":"iOS Dev","author":"杨小嘿","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-10-14T16:58:16.000Z","updated":"2017-10-14T17:25:09.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Algorithms4 习题 1_1_27 详解","slug":"Algorithms4-习题-1-1-27-详解","date":"2017-10-21T07:58:03.000Z","updated":"2017-10-21T07:58:30.000Z","comments":true,"path":"2017/10/21/Algorithms4-习题-1-1-27-详解/","link":"","permalink":"http://yoursite.com/2017/10/21/Algorithms4-习题-1-1-27-详解/","excerpt":"","text":"###提高题 1.1.27 二项分布 估计用以下代码计算 binomial(100, 50, 0.25) 将会产生的递归调用次数： 12345public static void binomial(int N, int k, double p) &#123; if (N == 0 &amp;&amp; k == 0) return 1.0; if (N &lt; 0 || k &lt; 0) return 0.0; return (1.0 - p) * binomial(N - 1, k ,p) + p * binomial(N - 1, k - 1, p);&#125; 将已经计算过的值保存在数组中并给出一个更好的实现 ####一，分析递归调用的次数 假设 N = 3, k = 2, p = 0.75, 分析函数的执行路径，我们可以得到函数首先不断的进入左侧的 (1.0 - p) * binomial(N - 1, k ,p) 表达式中, k 不变而 N 一直递减, 直到 if (N &lt; 0 || k &lt; 0) return 0.0; 返回 0.0 为止，才开始返回上一层函数，而在逐层返回的过程中，函数也在不断的进入右侧表达式 p * binomial(N - 1, k - 1, p), 将上述执行路径化成图像如下:","categories":[],"tags":[]}]}